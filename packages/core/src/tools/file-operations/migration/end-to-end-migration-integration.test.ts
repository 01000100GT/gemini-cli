/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import * as fs from 'node:fs';
import * as path from 'node:path';
import * as os from 'node:os';
import { Config } from '../../../config/config.js';
import { ToolRegistry } from '../../tool-registry.js';
import { MigrationAwareToolRegistry } from './migration-tool-registry.js';
import { 
  FileOperationsMigrationConfig, 
  MigrationPhase, 
  MIGRATION_PRESETS 
} from './migration-config.js';
import { MigrationManager } from './migration-manager.js';
import { UsageMetricsCollector } from './usage-metrics.js';
import { ConfigBasedRollbackController, ROLLBACK_POLICIES } from './config-based-rollback.js';
import { MetricsDashboardGenerator } from './metrics-dashboard.js';\nimport { RollbackManager } from './rollback-manager.js';\nimport { MigrationMetrics } from './migration-metrics.js';\n\n/**\n * End-to-end migration tests covering the complete migration lifecycle\n */\ndescribe('FileOperations Migration End-to-End Tests', () => {\n  let tempDir: string;\n  let configPath: string;\n  let config: Config;\n  let originalConsoleLog: typeof console.log;\n  \n  beforeEach(async () => {\n    // Create temporary directory for test files\n    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'gemini-migration-test-'));\n    configPath = path.join(tempDir, 'settings.json');\n    \n    // Mock console.log to reduce test noise\n    originalConsoleLog = console.log;\n    console.log = vi.fn();\n    \n    // Create test configuration\n    config = createTestConfig(tempDir);\n  });\n  \n  afterEach(() => {\n    // Cleanup\n    console.log = originalConsoleLog;\n    if (fs.existsSync(tempDir)) {\n      fs.rmSync(tempDir, { recursive: true, force: true });\n    }\n  });\n  \n  describe('Migration Lifecycle', () => {\n    it('should complete full migration lifecycle from disabled to full', async () => {\n      // Phase 1: Start with disabled migration\n      const disabledConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        phase: MigrationPhase.DISABLED,\n      };\n      \n      config = createTestConfigWithMigration(tempDir, disabledConfig);\n      const registry = await config.getToolRegistry();\n      \n      // Should use standard registry\n      expect(registry).toBeInstanceOf(ToolRegistry);\n      expect(registry).not.toBeInstanceOf(MigrationAwareToolRegistry);\n      \n      // Phase 2: Enable adapters phase\n      const adaptersConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        phase: MigrationPhase.ADAPTERS,\n        rolloutPercentage: 25,\n      };\n      \n      config = createTestConfigWithMigration(tempDir, adaptersConfig);\n      const migrationRegistry = await config.getToolRegistry();\n      \n      // Should use migration-aware registry\n      expect(migrationRegistry).toBeInstanceOf(MigrationAwareToolRegistry);\n      \n      // Phase 3: Gradual rollout\n      for (const percentage of [50, 75, 100]) {\n        const rolloutConfig: FileOperationsMigrationConfig = {\n          ...adaptersConfig,\n          rolloutPercentage: percentage,\n        };\n        \n        config = createTestConfigWithMigration(tempDir, rolloutConfig);\n        const rolloutRegistry = await config.getToolRegistry();\n        \n        expect(rolloutRegistry).toBeInstanceOf(MigrationAwareToolRegistry);\n        expect(config.getFileOperationsMigration().rolloutPercentage).toBe(percentage);\n      }\n      \n      // Phase 4: Full migration\n      const fullConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.PRODUCTION_FULL,\n        phase: MigrationPhase.FULL,\n      };\n      \n      config = createTestConfigWithMigration(tempDir, fullConfig);\n      const fullRegistry = await config.getToolRegistry();\n      \n      expect(fullRegistry).toBeInstanceOf(MigrationAwareToolRegistry);\n      expect(config.getFileOperationsMigration().phase).toBe(MigrationPhase.FULL);\n    });\n    \n    it('should handle tool-specific migration configuration', async () => {\n      const toolSpecificConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        phase: MigrationPhase.ADAPTERS,\n        tools: {\n          readFile: {\n            enabled: true,\n            rolloutPercentage: 100,\n          },\n          writeFile: {\n            enabled: false,\n          },\n          editTool: {\n            enabled: true,\n            rolloutPercentage: 50,\n            includeUsers: ['test-user-1'],\n          },\n        },\n      };\n      \n      config = createTestConfigWithMigration(tempDir, toolSpecificConfig);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      expect(registry).toBeInstanceOf(MigrationAwareToolRegistry);\n      \n      // Test user context for migration decisions\n      registry.setUserContext({ userId: 'test-user-1' });\n      \n      // ReadFile should use FileOperations (100% rollout)\n      const readTool = registry.getTool('ReadFileTool');\n      expect(readTool).toBeDefined();\n      \n      // WriteFile should use legacy (disabled)\n      const writeTool = registry.getTool('WriteFileTool');\n      expect(writeTool).toBeDefined();\n      \n      // EditTool should use FileOperations for included user\n      const editTool = registry.getTool('EditTool');\n      expect(editTool).toBeDefined();\n    });\n    \n    it('should respect user exclusion lists', async () => {\n      const exclusionConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        phase: MigrationPhase.ADAPTERS,\n        rolloutPercentage: 100,\n        tools: {\n          readFile: {\n            enabled: true,\n            excludeUsers: ['excluded-user'],\n          },\n        },\n      };\n      \n      config = createTestConfigWithMigration(tempDir, exclusionConfig);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      // Test excluded user\n      registry.setUserContext({ userId: 'excluded-user' });\n      const toolForExcludedUser = registry.getTool('ReadFileTool');\n      expect(toolForExcludedUser).toBeDefined();\n      \n      // Test normal user\n      registry.setUserContext({ userId: 'normal-user' });\n      const toolForNormalUser = registry.getTool('ReadFileTool');\n      expect(toolForNormalUser).toBeDefined();\n    });\n  });\n  \n  describe('Metrics and Monitoring', () => {\n    it('should collect and compare usage metrics', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      // Get metrics components\n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      \n      // Simulate tool usage\n      usageCollector.recordLegacyUsage('ReadFileTool', 100, true, 1024);\n      usageCollector.recordLegacyUsage('ReadFileTool', 150, true, 2048);\n      usageCollector.recordLegacyUsage('ReadFileTool', 200, false, 0);\n      \n      // Record A/B comparisons\n      usageCollector.recordABComparison('ReadFileTool', 150, 80, 1024);\n      usageCollector.recordABComparison('ReadFileTool', 200, 120, 2048);\n      \n      // Generate comparison\n      const comparison = usageCollector.generateToolComparison('ReadFileTool', 1);\n      \n      expect(comparison).toBeDefined();\n      expect(comparison!.toolName).toBe('ReadFileTool');\n      expect(comparison!.legacy.totalCalls).toBe(3);\n      expect(comparison!.legacy.successfulCalls).toBe(2);\n      expect(comparison!.legacy.errorRate).toBeCloseTo(1/3);\n      \n      // Generate aggregated metrics\n      const aggregated = usageCollector.generateAggregatedMetrics(1);\n      expect(aggregated.byTool['ReadFileTool']).toBeDefined();\n      expect(aggregated.summary.totalLegacyCalls).toBeGreaterThan(0);\n    });\n    \n    it('should generate migration dashboard', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const migrationManager = new MigrationManager(\n        config.getFileOperationsMigration(),\n        migrationMetrics\n      );\n      \n      const dashboardGenerator = new MetricsDashboardGenerator(\n        usageCollector,\n        migrationMetrics,\n        migrationManager,\n        config.getFileOperationsMigration()\n      );\n      \n      // Generate dashboard\n      const dashboard = dashboardGenerator.generateDashboard();\n      \n      expect(dashboard.overview.status).toBe('adapters');\n      expect(dashboard.performance.latencyComparison).toBeInstanceOf(Array);\n      expect(dashboard.adoption.byTool).toBeDefined();\n      expect(dashboard.quality.errorRates).toBeInstanceOf(Array);\n      \n      // Generate export\n      const exportData = dashboardGenerator.generateExport(7);\n      \n      expect(exportData.metadata.configuration).toBeDefined();\n      expect(exportData.aggregatedMetrics).toBeDefined();\n      expect(exportData.analysis.trends).toBeDefined();\n      expect(exportData.analysis.recommendations).toBeInstanceOf(Array);\n    });\n    \n    it('should export metrics in multiple formats', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const migrationManager = new MigrationManager(\n        config.getFileOperationsMigration(),\n        migrationMetrics\n      );\n      \n      const dashboardGenerator = new MetricsDashboardGenerator(\n        usageCollector,\n        migrationMetrics,\n        migrationManager,\n        config.getFileOperationsMigration()\n      );\n      \n      // Test JSON export\n      const jsonPath = path.join(tempDir, 'metrics.json');\n      dashboardGenerator.exportMetricsJSON(jsonPath, 7);\n      expect(fs.existsSync(jsonPath)).toBe(true);\n      \n      const jsonData = JSON.parse(fs.readFileSync(jsonPath, 'utf-8'));\n      expect(jsonData.metadata).toBeDefined();\n      expect(jsonData.aggregatedMetrics).toBeDefined();\n      \n      // Test CSV export\n      const csvDir = path.join(tempDir, 'csv');\n      fs.mkdirSync(csvDir);\n      dashboardGenerator.exportMetricsCSV(csvDir, 7);\n      \n      expect(fs.existsSync(path.join(csvDir, 'summary.csv'))).toBe(true);\n      expect(fs.existsSync(path.join(csvDir, 'per-tool.csv'))).toBe(true);\n      \n      // Test HTML export\n      const htmlPath = path.join(tempDir, 'dashboard.html');\n      dashboardGenerator.exportDashboardHTML(htmlPath);\n      expect(fs.existsSync(htmlPath)).toBe(true);\n      \n      const htmlContent = fs.readFileSync(htmlPath, 'utf-8');\n      expect(htmlContent).toContain('FileOperations Migration Dashboard');\n      expect(htmlContent).toContain('Overview');\n    });\n  });\n  \n  describe('Rollback Mechanisms', () => {\n    it('should trigger automatic rollback on high error rates', async () => {\n      const rollbackConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.PRODUCTION_CANARY,\n        rollback: {\n          autoRollback: true,\n          errorThreshold: 0.1, // 10%\n          performanceThreshold: 2.0,\n          minSampleSize: 5,\n        },\n      };\n      \n      config = createTestConfigWithMigration(tempDir, rollbackConfig);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const rollbackManager = new RollbackManager(\n        rollbackConfig,\n        migrationMetrics,\n        usageCollector\n      );\n      \n      // Simulate high error rate\n      for (let i = 0; i < 10; i++) {\n        migrationMetrics.recordOperation('ReadFileTool', i < 6, 100); // 60% success rate = 40% error rate\n      }\n      \n      // Check rollback conditions\n      rollbackManager.checkRollbackConditions();\n      \n      const status = rollbackManager.getRollbackStatus();\n      expect(status.activeRollbacks.length).toBeGreaterThan(0);\n      \n      // Verify rollback was triggered\n      const activeRollback = status.activeRollbacks[0];\n      expect(activeRollback.scope).toBe('tool');\n      expect(activeRollback.trigger).toBe('auto_error_rate');\n    });\n    \n    it('should handle configuration-based rollback', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const rollbackManager = new RollbackManager(\n        config.getFileOperationsMigration(),\n        migrationMetrics,\n        usageCollector\n      );\n      \n      const rollbackController = new ConfigBasedRollbackController(\n        rollbackManager,\n        ROLLBACK_POLICIES.conservative,\n        configPath\n      );\n      \n      // Create checkpoint\n      const checkpointPath = rollbackController.createRollbackCheckpoint('test-checkpoint');\n      expect(fs.existsSync(checkpointPath)).toBe(true);\n      \n      // Trigger emergency rollback\n      rollbackController.triggerEmergencyRollback('Test emergency');\n      \n      // Verify emergency config was written\n      const emergencyConfig = JSON.parse(fs.readFileSync(configPath, 'utf-8'));\n      expect(emergencyConfig.fileOperationsMigration.phase).toBe('disabled');\n      expect(emergencyConfig.fileOperationsMigration.emergency.triggered).toBe(true);\n      \n      // Restore from checkpoint\n      const restored = rollbackController.restoreFromCheckpoint(checkpointPath);\n      expect(restored).toBe(true);\n    });\n    \n    it('should generate rollback commands and documentation', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const rollbackManager = new RollbackManager(\n        config.getFileOperationsMigration(),\n        migrationMetrics,\n        usageCollector\n      );\n      \n      const rollbackController = new ConfigBasedRollbackController(\n        rollbackManager,\n        ROLLBACK_POLICIES.balanced\n      );\n      \n      // Generate rollback commands\n      const commands = rollbackController.generateRollbackCommands();\n      \n      expect(commands.immediate).toBeInstanceOf(Array);\n      expect(commands.gradual).toBeInstanceOf(Array);\n      expect(commands.recovery).toBeInstanceOf(Array);\n      \n      expect(commands.immediate.some(cmd => cmd.includes('disabled'))).toBe(true);\n      expect(commands.gradual.some(cmd => cmd.includes('rolloutPercentage'))).toBe(true);\n      \n      // Generate documentation\n      const documentation = rollbackController.generateRollbackDocumentation();\n      \n      expect(documentation).toContain('FileOperations Rollback Guide');\n      expect(documentation).toContain('Emergency Rollback');\n      expect(documentation).toContain('Configuration Structure');\n    });\n  });\n  \n  describe('Performance Regression Tests', () => {\n    it('should not degrade performance compared to legacy tools', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      // Create test files\n      const testFiles = [];\n      for (let i = 0; i < 10; i++) {\n        const filePath = path.join(tempDir, `test-file-${i}.txt`);\n        fs.writeFileSync(filePath, `Test content ${i}\\n`.repeat(100));\n        testFiles.push(filePath);\n      }\n      \n      // Get tools\n      const readTool = registry.getTool('ReadFileTool');\n      expect(readTool).toBeDefined();\n      \n      // Benchmark read operations\n      const legacyTimes: number[] = [];\n      const fileOpsTimes: number[] = [];\n      \n      for (const filePath of testFiles) {\n        // Simulate legacy tool timing\n        const legacyStart = performance.now();\n        await readTool!.execute({ path: filePath });\n        const legacyEnd = performance.now();\n        legacyTimes.push(legacyEnd - legacyStart);\n        \n        // Simulate FileOperations timing (would be actual in real implementation)\n        const fileOpsStart = performance.now();\n        await readTool!.execute({ path: filePath });\n        const fileOpsEnd = performance.now();\n        fileOpsTimes.push(fileOpsEnd - fileOpsStart);\n      }\n      \n      // Calculate averages\n      const avgLegacyTime = legacyTimes.reduce((sum, time) => sum + time, 0) / legacyTimes.length;\n      const avgFileOpsTime = fileOpsTimes.reduce((sum, time) => sum + time, 0) / fileOpsTimes.length;\n      \n      // FileOperations should not be significantly slower (allow 2x degradation for test)\n      const performanceRatio = avgFileOpsTime / avgLegacyTime;\n      expect(performanceRatio).toBeLessThan(2.0);\n      \n      console.log(`Performance ratio: ${performanceRatio.toFixed(2)}`);\n    });\n    \n    it('should handle concurrent operations efficiently', async () => {\n      const config = createTestConfigWithMigration(tempDir, {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        features: {\n          predictiveCaching: false,\n          parallelExecution: true,\n          transactionManagement: true,\n          securityHardening: true,\n          advancedAnalytics: false,\n        },\n      });\n      \n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      // Create test files\n      const testFiles = [];\n      for (let i = 0; i < 20; i++) {\n        const filePath = path.join(tempDir, `concurrent-test-${i}.txt`);\n        fs.writeFileSync(filePath, `Concurrent test content ${i}`);\n        testFiles.push(filePath);\n      }\n      \n      const readTool = registry.getTool('ReadFileTool');\n      expect(readTool).toBeDefined();\n      \n      // Test concurrent reads\n      const concurrentStart = performance.now();\n      const concurrentPromises = testFiles.map(filePath => \n        readTool!.execute({ path: filePath })\n      );\n      await Promise.all(concurrentPromises);\n      const concurrentEnd = performance.now();\n      \n      // Test sequential reads\n      const sequentialStart = performance.now();\n      for (const filePath of testFiles) {\n        await readTool!.execute({ path: filePath });\n      }\n      const sequentialEnd = performance.now();\n      \n      const concurrentTime = concurrentEnd - concurrentStart;\n      const sequentialTime = sequentialEnd - sequentialStart;\n      \n      // Concurrent should be faster than sequential (allowing for overhead)\n      expect(concurrentTime).toBeLessThan(sequentialTime * 0.8);\n      \n      console.log(`Concurrent: ${concurrentTime.toFixed(2)}ms, Sequential: ${sequentialTime.toFixed(2)}ms`);\n    });\n  });\n  \n  describe('Error Handling and Recovery', () => {\n    it('should handle migration failures gracefully', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const readTool = registry.getTool('ReadFileTool');\n      expect(readTool).toBeDefined();\n      \n      // Test with non-existent file\n      const nonExistentPath = path.join(tempDir, 'non-existent-file.txt');\n      \n      await expect(readTool!.execute({ path: nonExistentPath })).rejects.toThrow();\n      \n      // Verify error was recorded in metrics\n      const migrationMetrics = registry.getMigrationMetrics();\n      const toolStats = migrationMetrics.getToolStats('ReadFileTool');\n      \n      expect(toolStats.errorCount).toBeGreaterThan(0);\n    });\n    \n    it('should recover from rollback and resume migration', async () => {\n      const rollbackConfig: FileOperationsMigrationConfig = {\n        ...MIGRATION_PRESETS.DEVELOPMENT,\n        rollback: {\n          autoRollback: true,\n          errorThreshold: 0.5,\n          performanceThreshold: 2.0,\n          minSampleSize: 3,\n        },\n      };\n      \n      const config = createTestConfigWithMigration(tempDir, rollbackConfig);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const rollbackManager = new RollbackManager(\n        rollbackConfig,\n        migrationMetrics,\n        usageCollector\n      );\n      \n      // Trigger rollback\n      const rollbackState = rollbackManager.triggerManualRollback(\n        'tool',\n        'ReadFileTool',\n        'Test rollback'\n      );\n      \n      expect(rollbackState.isActive).toBe(true);\n      \n      // Verify rollback is active\n      const status = rollbackManager.getRollbackStatus();\n      expect(status.activeRollbacks.length).toBe(1);\n      \n      // Revert rollback\n      const rollbackId = Object.keys(status.activeRollbacks)[0] || 'unknown';\n      const reverted = rollbackManager.revertRollback(rollbackId);\n      \n      expect(reverted).toBe(true);\n      \n      // Verify rollback was reverted\n      const newStatus = rollbackManager.getRollbackStatus();\n      expect(newStatus.activeRollbacks.length).toBe(0);\n    });\n  });\n  \n  describe('A/B Testing and Gradual Rollout', () => {\n    it('should support A/B testing with statistical analysis', async () => {\n      const config = createTestConfigWithMigration(tempDir, MIGRATION_PRESETS.DEVELOPMENT);\n      const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n      \n      const migrationMetrics = registry.getMigrationMetrics();\n      const usageCollector = new UsageMetricsCollector(migrationMetrics);\n      const migrationManager = new MigrationManager(\n        config.getFileOperationsMigration(),\n        migrationMetrics\n      );\n      \n      const dashboardGenerator = new MetricsDashboardGenerator(\n        usageCollector,\n        migrationMetrics,\n        migrationManager,\n        config.getFileOperationsMigration()\n      );\n      \n      // Simulate A/B test data\n      for (let i = 0; i < 100; i++) {\n        const legacyTime = 100 + Math.random() * 50; // 100-150ms\n        const fileOpsTime = 80 + Math.random() * 40; // 80-120ms (better performance)\n        \n        usageCollector.recordABComparison('ReadFileTool', legacyTime, fileOpsTime, 1024);\n      }\n      \n      // Generate A/B test report\n      const abReport = dashboardGenerator.generateABTestReport('ReadFileTool', 7);\n      \n      expect(abReport.tool).toBe('ReadFileTool');\n      expect(abReport.sampleSize.legacy).toBe(0); // No legacy data in this test\n      expect(abReport.metrics.performance.improvement).toBeDefined();\n      expect(abReport.significance.performanceSignificant).toBeDefined();\n      expect(abReport.recommendation).toMatch(/rollout|continue_test|investigate|rollback/);\n      \n      console.log('A/B Test Report:', JSON.stringify(abReport, null, 2));\n    });\n    \n    it('should handle gradual percentage-based rollout', async () => {\n      const rolloutPercentages = [10, 25, 50, 75, 100];\n      \n      for (const percentage of rolloutPercentages) {\n        const rolloutConfig: FileOperationsMigrationConfig = {\n          ...MIGRATION_PRESETS.DEVELOPMENT,\n          rolloutPercentage: percentage,\n        };\n        \n        const config = createTestConfigWithMigration(tempDir, rolloutConfig);\n        const registry = await config.getToolRegistry() as MigrationAwareToolRegistry;\n        \n        expect(registry).toBeInstanceOf(MigrationAwareToolRegistry);\n        expect(config.getFileOperationsMigration().rolloutPercentage).toBe(percentage);\n        \n        // Simulate user requests with different user IDs\n        for (let userId = 0; userId < 100; userId++) {\n          registry.setUserContext({ userId: `user-${userId}` });\n          \n          // Get migration stats for this percentage\n          const stats = registry.getMigrationStats();\n          // In a real implementation, we'd verify that approximately\n          // `percentage`% of users get FileOperations\n        }\n      }\n    });\n  });\n});\n\n// Helper functions\n\nfunction createTestConfig(targetDir: string): Config {\n  return new Config({\n    contentGeneratorConfig: {\n      model: 'test-model',\n      apiKey: 'test-key',\n    },\n    embeddingModel: 'test-embedding',\n    targetDir,\n    debugMode: false,\n  });\n}\n\nfunction createTestConfigWithMigration(\n  targetDir: string,\n  migrationConfig: FileOperationsMigrationConfig\n): Config {\n  return new Config({\n    contentGeneratorConfig: {\n      model: 'test-model',\n      apiKey: 'test-key',\n    },\n    embeddingModel: 'test-embedding',\n    targetDir,\n    debugMode: false,\n    fileOperationsMigration: migrationConfig,\n  });\n}\n